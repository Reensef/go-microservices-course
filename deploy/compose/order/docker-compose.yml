services: # Здесь описываются контейнеры, необходимые для order сервиса

  order-postgres:
    image: postgres:17.0-alpine3.20
    # Используем официальный образ PostgreSQL версии 17 на базе Alpine Linux
    # Это лёгкая и быстрая сборка, которая экономит ресурсы

    container_name: order-postgres
    # Устанавливаем уникальное имя контейнера, чтобы было удобно обращаться к нему в CLI и при отладке

    environment: # Переменные окружения, используемые при запуске контейнера
      POSTGRES_USER: ${POSTGRES_USER} # Пользователь базы данных из .env
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD} # Пароль базы данных из .env

    volumes:
      - order_postgres_data:/var/lib/postgresql/data
      # Определяем том, который будет использоваться для хранения данных PostgreSQL
      # Он сохраняет данные между перезапусками контейнера

    ports:
      - "${POSTGRES_PORT}:5432"
      # Пробрасываем внутренний порт PostgreSQL (5432) на порт хоста
      # Это нужно, чтобы другие сервисы или инструменты могли подключиться к базе

    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER}" ]
      # Настраиваем проверку готовности контейнера — pg_isready проверяет, принимает ли база подключения
      interval: 10s  # Интервал между проверками — каждые 10 секунд
      timeout: 5s    # Время ожидания ответа от проверки
      retries: 5     # После 5 неудачных попыток подряд контейнер считается "unhealthy"

    restart: unless-stopped
    # Автоматически перезапускаем контейнер, если он аварийно завершился
    # Если контейнер был остановлен вручную — не перезапускаем

    networks:
      - microservices-net
      # Подключаемся к общей сети, чтобы другие микросервисы могли найти этот контейнер по имени "order-postgres"

volumes: # Раздел с томами — определяем, какие дисковые ресурсы создаёт и использует Docker
  order_postgres_data:
  # Именованный том для хранения данных в PostgreSQL
  # Позволяет сохранять состояние базы даже после перезапуска контейнера
